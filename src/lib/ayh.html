<!DOCTYPE html>
<html>
<head>
  <title>Matter.js H - Lower Arch</title>
  <style>
    body { margin: 0; padding: 0; overflow: hidden; background: #8c6a48; }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/poly-decomp@0.3.0/build/decomp.min.js"></script>
</head>
<body>
<script>

const Engine = Matter.Engine,
      Render = Matter.Render,
      Runner = Matter.Runner,
      Bodies = Matter.Bodies,
      Composite = Matter.Composite;

const engine = Engine.create();
const world = engine.world;

const render = Render.create({
    element: document.body,
    engine: engine,
    options: {
        width: window.innerWidth,
        height: window.innerHeight,
        wireframes: false, 
        background: '#8c6a48'
    }
});

function getHVertices() {
    const vertices = [];
    
    // CONFIGURATION
    const stemWidth = 100;
    const totalHeight = 350;
    const archStartY = 200; // <--- THIS IS LOWERED (Was effectively 70 before)
    const legWidth = 70;
    const radius = 80;
    
    // 1. LEFT STEM (The tall part)
    vertices.push({ x: 0, y: totalHeight });        // Bottom Left
    vertices.push({ x: 15, y: 15 });                 // Top Left (tapered)
    vertices.push({ x: stemWidth, y: 0 });          // Top Right of Stem
    
    // 2. THE "NECK" (The straight line down to the arch)
    vertices.push({ x: stemWidth, y: archStartY }); 

    // 3. OUTER ARCH
    const archCx = stemWidth + 0; 
    const archCy = archStartY + radius; 

    // Loop for Outer Curve (Top -> Right)
    for (let i = 0; i <= 20; i++) {
        const angle = -Math.PI / 2 + (i / 20) * (Math.PI / 2);
        vertices.push({
            x: archCx + radius * Math.cos(angle), 
            y: archCy + radius * Math.sin(angle)
        });
    }

    // 4. RIGHT LEG
    // The curve ends at the top of the right leg, so we draw down to the foot
    const rightLegX = archCx + radius;
    vertices.push({ x: rightLegX + 5, y: totalHeight }); // Bottom Right (tapered out slightly)

    // 5. INNER ARCH (The concave hole)
    // Bottom of the inner leg
    vertices.push({ x: rightLegX - legWidth + 10, y: totalHeight }); 
    
    // Loop for Inner Curve (Right -> Top)
    // We use a smaller radius to create thickness
    const innerRadius = radius - legWidth + 10; // varying thickness
    
    for (let i = 0; i <= 15; i++) {
        // Trace backwards from 0 to -PI/2
        const angle = 0 - (i / 15) * (Math.PI / 2);
        vertices.push({
            x: archCx + innerRadius * Math.cos(angle),
            y: archCy + innerRadius * Math.sin(angle) + 20 // Offset Y slightly
        });
    }
    
    // Connect back to the stem
    vertices.push({ x: stemWidth, y: totalHeight }); 

    return vertices;
}

const hVertices = getHVertices();

const letterH = Bodies.fromVertices(
    window.innerWidth / 2, 
    window.innerHeight / 2, 
    [hVertices], 
    {
        render: {
            fillStyle: '#dcd3c3',
            strokeStyle: '#dcd3c3',
            lineWidth: 1
        },
        restitution: 0.5,
        friction: 0.5
    },
    true 
);

const ground = Bodies.rectangle(window.innerWidth/2, window.innerHeight, window.innerWidth, 60, { 
    isStatic: true,
    render: { fillStyle: '#5e4631' }
});

Composite.add(world, [letterH, ground]);

Render.run(render);
const runner = Runner.create();
Runner.run(runner, engine);

// Mouse Control
const Mouse = Matter.Mouse, MouseConstraint = Matter.MouseConstraint;
const mouse = Mouse.create(render.canvas);
const mouseConstraint = MouseConstraint.create(engine, {
    mouse: mouse,
    constraint: { stiffness: 0.2, render: { visible: false } }
});
Composite.add(world, mouseConstraint);

</script>
</body>
</html>